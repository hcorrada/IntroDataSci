---
title:  "Project 4: Classification"
author: "CMSC320"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=FALSE)
```

**Last Update**: `r Sys.Date()`

## Data

We will use Mortgage Affordability data from Zillow to experiment with classification algorithms. The data was downloaded from Zillow Research page: https://www.zillow.com/research/data/

It is made available here: http://www.hcbravo.org/IntroDataSci/misc/Affordability_Wide_2017Q4_Public.csv

Download the csv file to your project directory.

### Preparing data

First, we will tidy the data. Please include this piece of code in your submission.

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(tidyverse)
library(lubridate)
theme_set(theme_bw())
```

```{r}
csv_file <- "Affordability_Wide_2017Q4_Public.csv"
tidy_afford <- read_csv(csv_file) %>%
  filter(Index == "Mortgage Affordability") %>%
  drop_na() %>%
  filter(RegionID != 0, RegionName != "United States") %>%
  dplyr::select(RegionID, RegionName, matches("^[1|2]")) %>%
  gather(time, affordability, matches("^[1|2]")) %>%
  type_convert(col_types=cols(time=col_date(format="%Y-%m")))
tidy_afford
```

This is what the data looks like:

```{r}
tidy_afford %>%
  ggplot(aes(x=time,y=affordability,group=factor(RegionID))) +
  geom_line(color="GRAY", alpha=3/4, size=1/2) +
  labs(title="County-Level Mortgage Affordability over Time",
          x="Date", y="Mortgage Affordability")
```

## The prediction task

The prediction task we are going to answer is:

> Can we predict if mortgage affordability will increase or decrease a year from now"

Specifically, we will do this for quarter 4 (Q4) of 2017. To create the outcome we will predict we will compare affordability for Q4 of 2017 to Q4 of 2016 and label it as `up` or `down` depending on the sign of the this difference. Let's create the outcome we want to predict (again, copy this bit of code to your submission):

```{r}
outcome_df <- tidy_afford %>%
  mutate(yq = quarter(time, with_year=TRUE)) %>%
  filter(yq %in% c("2016.4", "2017.4")) %>%
  select(RegionID, RegionName, yq, affordability) %>%
  spread(yq, affordability) %>%
  mutate(diff = `2017.4` - `2016.4`) %>%
  mutate(Direction = ifelse(diff>0, "up", "down")) %>%
  select(RegionID, RegionName, Direction)
outcome_df
```

Now, you have a dataframe with outcomes (labels) for each county in the dataset.

The goal is then given predictors $X_i$ for county $i$, build a classifier for outcome $G_i \in \{\mathtt{up},\mathtt{down}\}$.

To train your classifiers you should use data up to 2016. 

```{r}
predictor_df <- tidy_afford %>%
  filter(year(time) <= 2016)
```

## Your project

Your goal for this project is to do an experiment to address a (one, single) technical question about our ability to make this prediction. Here is a list of possible questions you may address below. Each of them asks to compare two specific choices in the classification workflow (e.g., two classification algorithms, two feature representations, etc.). You will implement each of the two choices and use 10-fold cross validation (across RegionID's) to compare their relative performance. You will also create an AUROC curve to compare them.

### Possible Questions

#### Feature representation and preprocessing

- Does standardizing affordability for each region affect  prediction performance? Compare standardized to non-standardized affordability.
- Is using quarter to quarter change (continuous or discrete) improve prediction performance? Compare quarter to quarter change in affordability as predictors to affordability as predictor?
- Should we use the full time series for each region, or should we use only the last few years? Compare full time series to a subset of the time series?
- Should we expand the training set to multiple time series per region? For example, create a similar outcome for each time point in the dataset (change relative to affordability one year ago) and use data from the last couple of years as predictors. Train on the extended dataset and test on the 2017 data above?
- Should we do dimensionality reduction (PCA) and use the embedded data to do prediction?
- Create your own question!

#### Classification Algorithm

- Is a decision tree better than logistic regression?
- Is a random forest better than a decision tree?
- Is K-nearest neighbors bettern than a random forest?
- Create your own question!

Note that you still have to make some choices regardless of the question you choose. For example, to do the feature preprocessing and representation experiments you have to choose a classifier (random forest for example), and decide what to do about hyper-parameters if appropriate.

## Submission

Prepare an Rmarkdown file which includes:

1) Code to prepare data (copied from chunks above)
2) Discussion of the question you have chosen to address including discussion of other choices you have made (e.g., feature representation, classification algorithm) to carry out your experiment.
3) Code to carry out your cross-validation experiment.
4) Table (result of hypothesis testing difference between algorithms) and plot comparing AUROCs
5) ROC curves for both experimental settings.
5) Interpretation and discussion of your experiment results.

Knit to PDF and submit on ELMS.

## An example experiment

Question: Does the number of trees used in a random forest classifier affect
performance (AUROC measured with 5-fold CV)?

Other decisions: We are transforming input data to use quarterly differences after data standardization for years 2014-2016. 

### Data preparation

First, filter to the years of interest and standardize affordability for each region

```{r}
standardized_df <- predictor_df %>%
  filter(year(time) %in% 2014:2016) %>%
  group_by(RegionID) %>%
  mutate(mean_aff = mean(affordability)) %>%
  mutate(sd_aff = sd(affordability)) %>%
  mutate(z_aff = (affordability - mean_aff) / sd_aff) %>%
  ungroup()
standardized_df
```

To train our model we need a table with one row per region, and attributes corresponding to differences in quarterly affordability. We will do this in stages, first we turn the tidy dataset into a wide dataset using `tidyr::spread` then create a dataframe containing the differences we use as features.

```{r}
wide_df <- standardized_df %>%
  select(RegionID, time, z_aff) %>%
  tidyr::spread(time, z_aff)
wide_df
```

Now, we turn this into quarterly differences

```{r}
matrix_1 <- wide_df %>%
  select(-RegionID) %>%
  as.matrix() %>%
  .[,-1]

matrix_2 <- wide_df %>%
  select(-RegionID) %>%
  as.matrix() %>%
  .[,-ncol(.)]

diff_df <- (matrix_1 - matrix_2) %>%
  magrittr::set_colnames(NULL) %>%
  as_data_frame() %>%
  mutate(RegionID = wide_df$RegionID)
```

Finally, add the outcome we want to predict from the data frame we created previously.

```{r}
final_df <- diff_df %>%
  inner_join(outcome_df %>% select(RegionID, Direction), by="RegionID") %>%
  mutate(Direction=factor(Direction, levels=c("down", "up"))) %>%
  select(-RegionID)
final_df
```


### Run the experiment 

We will use but 5-fold cross-validation to compare a random forest with 500 trees, with a random forest with 10 trees. Since this is a smallish dataset, I am using 5-fold cross validation to make the validation sets have more examples and therefore more reliable performance estimates.

We use the `caret::createFolds` function to create a stratified 5-fold cross-validation partition. The result is a list of length 5, containing the indices of the examples used for validation in each of the cross-validation folds.

We use the `train` function in the `caret` package to organize our model training. It takes
a `trControl` argument which sets up how to score models. Here we tell it to use 5-fold cross validation and measure sensitivity and specificity as performance metrics (`twoClassSummary`). We also tell it to
`savePredictions` so we can make ROC plots later on. Other parameters needed by the `randomForest` function are passed through the `train` function.

```{r, cache=FALSE}
library(caret)
set.seed(1234)
```

```{r, cache=FALSE}
# create the cross-validation partition
cv_partition <- createFolds(final_df$Direction,
                            k=5)

fit_control <- trainControl( ## 5-fold CV
  method = "cv",
  number = 5,
  indexOut = cv_partition,
  summaryFunction=twoClassSummary,
  classProbs=TRUE,
  savePredictions=TRUE)

big_rf_fit <- train(Direction~.,
                    data=final_df,
                    method = "rf",
                    ntree = 500,
                    trControl = fit_control,
                    metric="ROC")
                    

small_rf_fit <- train(Direction~.,
                      data = final_df,
                      method = "rf",
                      ntree = 10,
                      trControl = fit_control,
                      metric="ROC")


show(big_rf_fit)
small_rf_fit
```

Now let's compare models based on 5-CV area under the ROC curve (AUROC). For that purpose we use the `resamples` function in `caret`, which organizes the estimated AUROC values from each fold.

```{r, cache=FALSE}
model_comparison <- resamples(list(small = small_rf_fit,
                              big=big_rf_fit))
ggplot(model_comparison) +
  labs(title="ROC comparision", x="Model", y="ROC")
```

We can test for differences using linear regression.

```{r}
library(broom)

comparison_df <- model_comparison %>%
  as_tibble() %>%
  gather("model", "roc", -Resample) %>%
  mutate(model=factor(model, levels=c("small","big"))) 

comparison_df %>%
  lm(roc~model,data=.) %>%
  tidy() %>%
  knitr::kable()
```

We see that there is a small increase in average AUROC for the big model but it is not a statistically significant difference.

Finally, let's make ROC curves of both models. 

```{r, warning=FALSE}
library(plotROC)

roc_df <-
  big_rf_fit$pred %>%
    filter(mtry == 2) %>%
    mutate(model = "big") %>%
    bind_rows(small_rf_fit$pred %>% 
                filter(mtry == 2) %>%
                mutate(model = "small"))

roc_df %>%
  ggplot(aes(m=up,
             d=factor(obs, levels=c("down","up")),
             color=model)) +
    geom_roc(n.cuts=0) +
    coord_equal() +
    style_roc() 
```

