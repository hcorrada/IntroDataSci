---
title:  "Project 4: Classification"
author: "CMSC320"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, cache=TRUE)
```

**Last Update**: `r Sys.Date()`

## Data

We will use Mortgage Affordability data from Zillow to experiment with classification algorithms. The data was downloaded from Zillow Research page: https://www.zillow.com/research/data/

It is made available here: http://www.hcbravo.org/IntroDataSci/misc/Affordability_Wide_2017Q4_Public.csv

Download the csv file to your project directory.

### Preparing data

First, we will tidy the data. Please include this piece of code in your submission.

```{r, message=FALSE, warning=FALSE, cache=FALSE}
library(tidyverse)
library(lubridate)
theme_set(theme_bw())
```

```{r}
csv_file <- "Affordability_Wide_2017Q4_Public.csv"
tidy_afford <- read_csv(csv_file) %>%
  filter(Index == "Mortgage Affordability") %>%
  drop_na() %>%
  filter(RegionID != 0, RegionName != "United States") %>%
  dplyr::select(RegionID, RegionName, matches("^[1|2]")) %>%
  gather(time, affordability, matches("^[1|2]")) %>%
  type_convert(col_types=cols(time=col_date(format="%Y-%m")))
tidy_afford
```

This is what the data looks like:

```{r}
tidy_afford %>%
  ggplot(aes(x=time,y=affordability,group=factor(RegionID))) +
  geom_line(color="GRAY", alpha=3/4, size=1/2) +
  labs(title="County-Level Mortgage Affordability over Time",
          x="Date", y="Mortgage Affordability")
```

## The prediction task

The prediction task we are going to answer is:

> Can we predict if mortgage affordability will increase or decrease a year from now"

Specifically, we will do this for quarter 4 (Q4) of 2017. To create the outcome we will predict we will compare affordability for Q4 of 2017 to Q4 of 2016 and label it as `up` or `down` depending on the sign of the this difference. Let's create the outcome we want to predict (again, copy this bit of code to your submission):

```{r}
outcome_df <- tidy_afford %>%
  mutate(yq = quarter(time, with_year=TRUE)) %>%
  filter(yq %in% c("2016.4", "2017.4")) %>%
  select(RegionID, RegionName, yq, affordability) %>%
  spread(yq, affordability) %>%
  mutate(diff = `2017.4` - `2016.4`) %>%
  mutate(Direction = ifelse(diff>0, "up", "down")) %>%
  select(RegionID, RegionName, Direction)
outcome_df
```

Now, you have a dataframe with outcomes (labels) for each county in the dataset.

The goal is then given predictors $X_i$ for county $i$, build a classifier for outcome $G_i \in \{\mathtt{up},\mathtt{down}\}$.

To train your classifiers you should use data up to 2016. 

```{r}
predictor_df <- tidy_afford %>%
  filter(year(time) <= 2016)
```

## Your project

Your goal for this project is to do an experiment to address a (one, single) technical question about our ability to make this prediction. Here is a list of possible questions you may address below. Each of them asks to compare two specific choices in the classification workflow (e.g., two classification algorithms, two feature representations, etc.). You will implement each of the two choices and use 10-fold cross validation (across RegionID's) to compare their relative performance. You will also create an AUROC curve to compare them.

### Possible Questions

#### Feature representation and preprocessing

- Does standardizing affordability for each region affect  prediction performance? Compare standardized to non-standardized affordability.
- Is using quarter to quarter change (continuous or discrete) improve prediction performance? Compare quarter to quarter change in affordability as predictors to affordability as predictor?
- Should we use the full time series for each region, or should we use only the last few years? Compare full time series to a subset of the time series?
- Should we expand the training set to multiple time series per region? For example, create a similar outcome for each time point in the dataset (change relative to affordability one year ago) and use data from the last couple of years as predictors. Train on the extended dataset and test on the 2017 data above?
- Should we do dimensionality reduction (PCA) and use the embedded data to do prediction?
- Create your own question!

#### Classification Algorithm

- Is a decision tree better than logistic regression?
- Is a random forest better than a decision tree?
- Is K-nearest neighbors bettern than a random forest?
- Create your own question!

Note that you still have to make some choices regardless of the question you choose. For example, to do the feature preprocessing and representation experiments you have to choose a classifier (random forest for example), and decide what to do about hyper-parameters if appropriate.

## Submission

Prepare an Rmarkdown file which includes:

1) Code to prepare data (copied from chunks above), plus any additional data prep for your experiment.
2) Discussion of the question you have chosen to address including discussion of other choices you have made (e.g., feature representation, classification algorithm) to carry out your experiment.
3) Code to carry out your cross-validation experiment.
4) Table (result of hypothesis testing difference between algorithms) and plot comparing AUROCs
5) ROC curves for both experimental settings.
5) Interpretation and discussion of your experiment results.

Knit to PDF and submit on ELMS.

## An example experiment

**Question**: Does the number of trees used in a random forest classifier affect
performance (AUROC measured with 5-fold CV)?

**Other factors**: We are transforming input data to use quarterly differences after data standardization for years 2014-2016. 

### Data preparation

First, filter to the years of interest and standardize affordability for each region

```{r}
standardized_df <- predictor_df %>%
  filter(year(time) %in% 2014:2016) %>%
  group_by(RegionID) %>%
  mutate(mean_aff = mean(affordability)) %>%
  mutate(sd_aff = sd(affordability)) %>%
  mutate(z_aff = (affordability - mean_aff) / sd_aff) %>%
  ungroup()
standardized_df
```

To train our model we need a table with one row per region, and attributes corresponding to differences in quarterly affordability. We will do this in stages, first we turn the tidy dataset into a wide dataset using `tidyr::spread` then create a dataframe containing the differences we use as features.

```{r}
wide_df <- standardized_df %>%
  select(RegionID, time, z_aff) %>%
  tidyr::spread(time, z_aff)
wide_df
```

Now, we turn this into quarterly differences

```{r}
matrix_1 <- wide_df %>%
  select(-RegionID) %>%
  as.matrix() %>%
  .[,-1]

matrix_2 <- wide_df %>%
  select(-RegionID) %>%
  as.matrix() %>%
  .[,-ncol(.)]

diff_df <- (matrix_1 - matrix_2) %>%
  magrittr::set_colnames(NULL) %>%
  as_data_frame() %>%
  mutate(RegionID = wide_df$RegionID)
```

Finally, add the outcome we want to predict from the data frame we created previously.

```{r}
final_df <- diff_df %>%
  inner_join(outcome_df %>% select(RegionID, Direction), by="RegionID") %>%
  mutate(Direction=factor(Direction, levels=c("down", "up"))) %>%
  select(-RegionID)
final_df
```


### Run the experiment 

We will use but 5-fold cross-validation to compare a random forest with 500 trees, with a random forest with 10 trees. Since this is a smallish dataset, I am using 5-fold cross validation to make the validation sets have more examples and therefore more reliable performance estimates.

```{r, cache=FALSE}
library(caret)
set.seed(1234)
```

```{r, cache=FALSE}
# create the cross-validation partition
cv_partition <- createFolds(final_df$Direction,
                            k=5)

# setup training parameters
fit_control <- trainControl( ## 5-fold CV
  method = "cv",
  number = 5,
  #indexOut = cv_partition,
  summaryFunction=twoClassSummary,
  classProbs=TRUE,
  savePredictions=TRUE)


# a function to obtain performance data
# (tpr and fpr) over the given cross validation
# partitions, for the number of trees in the
# random forest
get_roc_data <- function(ntree, cv_partition) {
  mean_fpr <- seq(0, 1, len=100)
  aucs <- numeric(length(cv_partition))
  
  # iterate over folds
  res <- lapply(seq_along(cv_partition),  function(i) {
    # train the random forest 
    fit <- train(Direction~.,
                        data = final_df[-cv_partition[[i]],], # all but the holdout set
                        method = "rf",
                        ntree = ntree,
                        trControl = fit_control,
                        metric="ROC")
    
    # make predictions on the holdout set
    preds <- predict(fit, newdata=final_df[cv_partition[[i]],],type="prob")$up
    
    # compute tpr and fpr from the hold out set
    perf <- ROCR::prediction(preds, final_df$Direction[cv_partition[[i]]]) %>%
      ROCR::performance(measure="tpr", x.measure="fpr")

    fpr <- unlist(perf@x.values)
    tpr <- unlist(perf@y.values)
    
    # interpolate the roc curve over 0, 1 range
    interp_tpr <- approxfun(fpr, tpr)(mean_fpr)
    interp_tpr[1] <- 0.0
    
    # collect values for this fold
    data_frame(fold=rep(i, length(mean_fpr)), fpr=mean_fpr, tpr=interp_tpr)
  })
  
  # combine values across all folds
  # into a single data frame
  do.call(rbind, res)
}

# calculate area under the ROC curve
# from tpr and fpr values across folds
compute_auc <- function(curve_df) {
  curve_df %>% 
    group_by(fold) %>%
    summarize(auc=pracma::trapz(fpr, tpr))
}
```

```{r}
# get performance data for random forest with
# 10 trees
small_curve_df <- get_roc_data(ntree = 10, cv_partition)
small_auc_df <- compute_auc(small_curve_df)
```

```{r}
# get performance data for random forest with
# 500 trees
large_curve_df <- get_roc_data(ntree=500, cv_partition)
large_auc_df <- compute_auc(large_curve_df)
```


Now let's compare models based on 5-CV area under the ROC curve (AUROC). 

```{r, cache=FALSE}
# combine performance data for both models
# into one data frame (adding column to indicate)
# which model was used
curve_df <- small_curve_df %>%
  mutate(model="small") %>%
  rbind(mutate(large_curve_df, model="large")) %>%
  mutate(model = factor(model, levels=c("small", "large")))

auc_df <- small_auc_df %>%
  mutate(model="small") %>%
  rbind(mutate(large_auc_df, model="large")) %>%
  mutate(model = factor(model, levels=c("small", "large")))

# plot distribution of 
ggplot(auc_df, aes(x=model, y=auc)) +
  geom_jitter(position=position_jitter(0.1)) +
  coord_flip() + 
  labs(title="AUC comparision",
       x="Model",
       y="Area under ROC curve")
```

We test for differences using linear regression.

```{r}
library(broom)

model_tab <- auc_df %>%
  lm(auc~model,data=.) %>%
  tidy() 

model_tab %>%
  knitr::kable()
```

We see that there is a small increase (`r format(abs(model_tab$estimate[2]) * 100, digits=2)`%) in average AUROC for the big model but it is not a statistically significant difference.

Finally, here are ROC curves of both models. 

```{r, warning=FALSE}
curve_df %>%
  group_by(model, fpr) %>%
  summarize(tpr = mean(tpr)) %>%
  ggplot(aes(x=fpr, y=tpr, color=model)) +
    geom_line() +
    labs(title = "ROC curves",
         x = "False positive rate",
         y = "True positive rate")
```

The bigger model has higher true positive rate at lower false positive rates. The smaller model is better at high false positive rates. Neither model is very good at this prediction task, and there is no clear advantage in using either of these for the analysis task.
