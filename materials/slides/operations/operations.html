<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Operations</title>
    <meta charset="utf-8" />
    <meta name="author" content="Héctor Corrada Bravo" />
    <meta name="date" content="2019-08-01" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: title-slide, center, middle
count: false

.banner[![](img/epiviz.png)]

.title[Introduction to Data Science: Operations]

.author[Héctor Corrada Bravo]

.other-info[
University of Maryland, College Park, USA  
2019-08-01
]

.logo[![](img/logo.png)]

---



---
layout: true

## Principles: Basic Operations

Now that we have a data frame describing our data, let's learn a few fundamental operations we perform on data frames on almost any analysis. 

We divide these first set of operations into two groups: 

- operations on _attributes_ 
- operations on _entitites_. 


```
## # A tibble: 104,528 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    23 B     M     01/01/2011 00'00"     &lt;NA&gt;          
##  2 1.11e7    37 B     M     01/01/2011 01'00"     2000 Wilkens …
##  3 1.11e7    46 B     M     01/01/2011 01'00"     2800 Mayfield…
##  4 1.11e7    50 B     M     01/01/2011 04'00"     2100 Ashburto…
##  5 1.11e7    33 B     M     01/01/2011 05'00"     4000 Wilsby A…
##  6 1.11e7    41 B     M     01/01/2011 05'00"     2900 Spellman…
##  7 1.11e7    29 B     M     01/01/2011 05'00"     800 N Monroe …
##  8 1.11e7    20 W     M     01/01/2011 05'00"     5200 Moravia …
##  9 1.11e7    24 B     M     01/01/2011 07'00"     2400 Gainsdbo…
## 10 1.11e7    53 B     M     01/01/2011 15'00"     3300 Woodland…
## # … with 104,518 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```



---
layout: true

## Operations that select attributes

---

### `select`

In our data set we have a large number of attributes describing each arrest. 

We only want to study patterns in these arrests based on a smaller number of attributes.

In that case we would like to create a data frame that contains only those attributes of interest. 

We use the `select` function for this.

---

![](img/select.png)

---

Let's create a data frame containing only the `age`, `sex` and `district` attributes


```r
select(arrest_tab, age, sex, district)
```

```
## # A tibble: 104,528 x 3
##      age sex   district    
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       
##  1    23 M     &lt;NA&gt;        
##  2    37 M     SOUTHERN    
##  3    46 M     NORTHEASTERN
##  4    50 M     WESTERN     
##  5    33 M     NORTHERN    
##  6    41 M     SOUTHERN    
##  7    29 M     WESTERN     
##  8    20 M     NORTHEASTERN
##  9    24 M     &lt;NA&gt;        
## 10    53 M     NORTHWESTERN
## # … with 104,518 more rows
```

The first argument to `select` is a data frame, and the value returned by `select` is also a data frame

---

We can use an operator to describe ranges. E.g., `1:5` would be attributes 1 through 5:
  

```r
select(arrest_tab, 1:5)
```

```
## # A tibble: 104,528 x 5
##      arrest   age race  sex   arrestDate
##       &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;     
##  1 11126858    23 B     M     01/01/2011
##  2 11127013    37 B     M     01/01/2011
##  3 11126887    46 B     M     01/01/2011
##  4 11126873    50 B     M     01/01/2011
##  5 11126968    33 B     M     01/01/2011
##  6 11127041    41 B     M     01/01/2011
##  7 11126932    29 B     M     01/01/2011
##  8 11126940    20 W     M     01/01/2011
##  9 11127051    24 B     M     01/01/2011
## 10 11127018    53 B     M     01/01/2011
## # … with 104,518 more rows
```

---
layout: true

## Operations that select entities

---

![](img/subset.png)

---

### `slice`

We can choose specific entities by their row position. For instance, to choose entities in rows 1,3 and 10, we would use the following:


```r
slice(arrest_tab, c(1, 3, 10))
```

```
## # A tibble: 3 x 15
##   arrest   age race  sex   arrestDate arrestTime arrestLocation
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
## 1 1.11e7    23 B     M     01/01/2011 00'00"     &lt;NA&gt;          
## 2 1.11e7    46 B     M     01/01/2011 01'00"     2800 Mayfield…
## 3 1.11e7    53 B     M     01/01/2011 15'00"     3300 Woodland…
## # … with 8 more variables: incidentOffense &lt;chr&gt;, incidentLocation &lt;chr&gt;,
## #   charge &lt;chr&gt;, chargeDescription &lt;chr&gt;, district &lt;chr&gt;, post &lt;dbl&gt;,
## #   neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

As before, the first argument is the data frame to operate on. 

The second argument is a _vector_ of indices. 

We used the `c` function (for concatenate) to create a vector of indices.

---

We can also use the range operator here:


```r
slice(arrest_tab, 1:5)
```

```
## # A tibble: 5 x 15
##   arrest   age race  sex   arrestDate arrestTime arrestLocation
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
## 1 1.11e7    23 B     M     01/01/2011 00'00"     &lt;NA&gt;          
## 2 1.11e7    37 B     M     01/01/2011 01'00"     2000 Wilkens …
## 3 1.11e7    46 B     M     01/01/2011 01'00"     2800 Mayfield…
## 4 1.11e7    50 B     M     01/01/2011 04'00"     2100 Ashburto…
## 5 1.11e7    33 B     M     01/01/2011 05'00"     4000 Wilsby A…
## # … with 8 more variables: incidentOffense &lt;chr&gt;, incidentLocation &lt;chr&gt;,
## #   charge &lt;chr&gt;, chargeDescription &lt;chr&gt;, district &lt;chr&gt;, post &lt;dbl&gt;,
## #   neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

To create general sequences of indices we would use the `seq` function. For example, to select entities in even positions we would use the following:


```r
slice(arrest_tab, seq(2, nrow(arrest_tab), by=2))
```

```
## # A tibble: 52,264 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    37 B     M     01/01/2011 01'00"     2000 Wilkens …
##  2 1.11e7    50 B     M     01/01/2011 04'00"     2100 Ashburto…
##  3 1.11e7    41 B     M     01/01/2011 05'00"     2900 Spellman…
##  4 1.11e7    20 W     M     01/01/2011 05'00"     5200 Moravia …
##  5 1.11e7    53 B     M     01/01/2011 15'00"     3300 Woodland…
##  6 1.11e7    25 B     M     01/01/2011 20'00"     2800 Violet A…
##  7 1.11e7    50 B     M     01/01/2011 40'00"     2600 Oswego A…
##  8 1.11e7    40 B     M     01/01/2011 40'00"     3900 Greenmou…
##  9 1.11e7    30 B     M     01/01/2011 40'00"     900 N Calhoun…
## 10 1.11e7    53 B     M     01/01/2011 40'00"     900 N Calhoun…
## # … with 52,254 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

### `filter`

We can also select entities based on attribute properties. For example, to select arrests where age is less than 18 years old, we would use the following:


```r
filter(arrest_tab, age &lt; 18)
```

```
## # A tibble: 463 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    17 B     M     01/03/2011 15:00      &lt;NA&gt;          
##  2 1.11e7    17 B     M     01/07/2011 18:40      500 N Athol St
##  3 1.11e7    17 A     M     01/10/2011 22:00      &lt;NA&gt;          
##  4 1.11e7    17 B     M     01/13/2011 01:00      &lt;NA&gt;          
##  5 1.11e7    17 B     F     01/13/2011 13:40      1400 N Wilmer…
##  6 1.11e7    17 B     M     01/13/2011 18:40      1400 Wilmer St
##  7 1.11e7    14 B     M     01/17/2011 21:57      &lt;NA&gt;          
##  8 1.11e7    17 B     M     01/18/2011 15:00      &lt;NA&gt;          
##  9 1.11e7    17 B     M     01/18/2011 15:26      900 Seagull A…
## 10 1.11e7    16 B     M     01/18/2011 16:00      2300 N Charle…
## # … with 453 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

The second argument is an expression that evaluates to a logical value (`TRUE` or `FALSE`), if the expression evaluates to TRUE for a given entity (row) then that entity (row) is part of the resulting data frame. 

---

Operators used frequently include:

`==`, `!=`: tests equality and inequality respectively (categorical, numerical, datetimes, etc.)  
`&lt;`, `&gt;`, `&lt;=`, `&gt;=`: tests order relationships for ordered data types (not categorical)  
`!`, `&amp;`, `|`: not, and, or, logical operators

---

To select arrests with ages between 18 and 25 we can use


```r
filter(arrest_tab, age &gt;= 18 &amp; age &lt;= 25)
```

```
## # A tibble: 35,770 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    23 B     M     01/01/2011 00:00      &lt;NA&gt;          
##  2 1.11e7    20 W     M     01/01/2011 00:05      5200 Moravia …
##  3 1.11e7    24 B     M     01/01/2011 00:07      2400 Gainsdbo…
##  4 1.11e7    25 B     M     01/01/2011 00:20      2800 Violet A…
##  5 1.11e7    24 B     M     01/01/2011 00:40      3900 Greenmou…
##  6 1.11e7    20 B     M     01/01/2011 01:22      1900 Ashburto…
##  7 1.11e7    23 B     M     01/01/2011 01:30      2600 Aisquith…
##  8 1.11e7    22 A     M     01/01/2011 01:40      &lt;NA&gt;          
##  9 1.11e7    20 W     M     01/01/2011 02:00      300 S Bentalo…
## 10 1.11e7    20 B     M     01/01/2011 02:20      900 Myrtle Ave
## # … with 35,760 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

The filter function can take multiple logical expressions. In this case they are combined with `&amp;`. So the above is equivalent to


```r
filter(arrest_tab, age &gt;= 18, age &lt;= 25)
```

```
## # A tibble: 35,770 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    23 B     M     01/01/2011 00:00      &lt;NA&gt;          
##  2 1.11e7    20 W     M     01/01/2011 00:05      5200 Moravia …
##  3 1.11e7    24 B     M     01/01/2011 00:07      2400 Gainsdbo…
##  4 1.11e7    25 B     M     01/01/2011 00:20      2800 Violet A…
##  5 1.11e7    24 B     M     01/01/2011 00:40      3900 Greenmou…
##  6 1.11e7    20 B     M     01/01/2011 01:22      1900 Ashburto…
##  7 1.11e7    23 B     M     01/01/2011 01:30      2600 Aisquith…
##  8 1.11e7    22 A     M     01/01/2011 01:40      &lt;NA&gt;          
##  9 1.11e7    20 W     M     01/01/2011 02:00      300 S Bentalo…
## 10 1.11e7    20 B     M     01/01/2011 02:20      900 Myrtle Ave
## # … with 35,760 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

### `sample_n` and `sample_frac`

Frequently we will want to choose entities from a data frame at random. The `sample_n` function selects a specific number of entities at random:


```r
sample_n(arrest_tab, 10)
```

```
## # A tibble: 10 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.26e7    25 B     M     09/26/2012 22:25      0 N Howard St 
##  2 1.14e7    22 B     F     11/10/2011 18:00      2700 Kinsey St
##  3 1.13e7    44 B     F     06/25/2011 16:25      900 Pennsylva…
##  4 1.26e7    20 B     M     11/30/2012 23:55      2200 W. North…
##  5 1.26e7    20 B     F     11/24/2012 06:30      5200 Parkhigh…
##  6 1.12e7    19 B     M     03/09/2011 21:00      &lt;NA&gt;          
##  7 1.26e7    57 W     M     09/19/2012 20:45      5800 Key Ave  
##  8 1.13e7    18 B     M     07/03/2011 02:30      800 Battery A…
##  9 1.11e7    26 B     M     01/04/2011 22:20      2400 Annor Ct 
## 10 1.14e7    18 B     M     11/01/2011 11:15      1200 E 25Th St
## # … with 8 more variables: incidentOffense &lt;chr&gt;, incidentLocation &lt;chr&gt;,
## #   charge &lt;chr&gt;, chargeDescription &lt;chr&gt;, district &lt;chr&gt;, post &lt;dbl&gt;,
## #   neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

The `sample_frac` function selects a fraction of entitites at random:


```r
sample_frac(arrest_tab, .1)
```

```
## # A tibble: 10,453 x 15
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.13e7    34 B     M     09/26/2011 19:30      &lt;NA&gt;          
##  2 1.25e7    20 B     M     04/05/2012 04:30      1300 N Calhou…
##  3 1.11e7    26 B     M     02/04/2011 10:10      &lt;NA&gt;          
##  4 1.25e7    20 B     M     09/05/2012 10:45      &lt;NA&gt;          
##  5 1.26e7    32 B     M     11/08/2012 08:35      3800 Brehms Ln
##  6 1.25e7    45 W     F     03/31/2012 17:30      2100 Eagle St 
##  7 1.12e7    22 B     F     05/07/2011 00:30      &lt;NA&gt;          
##  8 1.26e7    28 U     M     11/20/2012 11:30      0 N Monroe St 
##  9 1.25e7    45 B     M     04/05/2012 10:30      1600 Carswell…
## 10 1.24e7    44 B     M     03/20/2012 07:00      &lt;NA&gt;          
## # … with 10,443 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

## Pipelines of operations

All of the functions implementing our first set of operations have the same argument/value structure. 

They take a data frame as a first argument and return a data frame. We refer to this as the _data--&gt;transform--&gt;data_ pattern. 

This is the core a lot of what we will do in class as part of data analyses. 

Specifically, we will combine operations into _pipelines_ that manipulate data frames.

---

In R, the `dplyr` package introduces _syntactic sugar_ to make this pattern explicit. 


```r
arrest_tab %&gt;%
  sample_frac(.1)
```

```
## # A tibble: 10,453 x 15
##     arrest   age race  sex   arrestDate arrestTime arrestLocation
##      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1  1.24e7    59 W     M     01/14/2012 17:50      600 Monroe St 
##  2  1.12e7    44 B     M     05/01/2011 00:30      &lt;NA&gt;          
##  3  1.24e7    26 W     M     03/28/2012 02:15      &lt;NA&gt;          
##  4  1.26e7    23 B     M     12/05/2012 11:28      &lt;NA&gt;          
##  5  1.26e7    31 B     M     09/24/2012 17:20      1900 E Federa…
##  6 NA         37 W     M     03/16/2011 02:00      1800 W. Mulbe…
##  7  1.13e7    29 B     M     06/27/2011 18:30      600 Braddish …
##  8  1.26e7    35 B     M     10/14/2012 11:50      &lt;NA&gt;          
##  9  1.25e7    26 B     M     04/01/2012 01:35      3200 Tivoly St
## 10  1.25e7    24 B     M     05/23/2012 19:00      &lt;NA&gt;          
## # … with 10,443 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

---

The `%&gt;%` binary operator takes the value to its **left** and inserts it as the first argument of the function call to its **right**. So the expression `LHS %&gt;% f(another_argument)` is **equivalent** to the expression `f(LHS, another_argument)`. 

In `pandas`, you can chain `.` calls.

---

Using the `%&gt;%` operator and the _data--&gt;transform--&gt;data_ pattern of the functions we've seen so far, we can create pipelines. 

---

For example, let's create a pipeline that:

1) filters our dataset to arrests between the ages of 18 and 25
2) selects attributes `sex`, `district` and `arrestDate` (renamed as `arrest_date`)
3) samples 50% of those arrests at random

We will assign the result to variable `analysis_tab`

---


```r
analysis_tab &lt;- arrest_tab %&gt;%
  filter(age &gt;= 18, age &lt;= 25) %&gt;%
  select(sex, district, arrest_date=arrestDate) %&gt;%
  sample_frac(.5)
analysis_tab
```

```
## # A tibble: 17,885 x 3
##    sex   district     arrest_date
##    &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;      
##  1 M     EASTERN      12/14/2012 
##  2 F     &lt;NA&gt;         08/10/2011 
##  3 M     &lt;NA&gt;         03/09/2012 
##  4 M     &lt;NA&gt;         04/06/2012 
##  5 M     WESTERN      01/06/2011 
##  6 M     SOUTHERN     01/31/2011 
##  7 M     NORTHEASTERN 09/15/2012 
##  8 M     SOUTHERN     09/22/2011 
##  9 M     NORTHWESTERN 11/17/2011 
## 10 M     &lt;NA&gt;         02/08/2011 
## # … with 17,875 more rows
```


---

**Exercise**: Create a pipeline that:

1) filters dataset to arrests from the "SOUTHERN" district occurring before "12:00" (`arrestTime`)
2) selects attributes, `sex`, `age`
3) samples 10 entities at random








# Principles: More Operations



In the previous section we introduced our first few operations to manipulate data frames. Next, we learn a few more: sorting, creating new attributes, summarizing and grouping. Finally we will take a short detour through a discussion on vectors. 

## Operations that sort entities

The first operation we will look at today is used to sort entities based on their attribute values. As an example, suppose we wanted to find the arrests with the 10 youngest subjects. If we had an operation that re-orders entities based on the value of their `age` attribute, we can then use the `slice` operation we saw before to create a data frame with just the entities of interest


```r
arrest_tab %&gt;%
  arrange(age) %&gt;%
  slice(1:10)
```

```
## # A tibble: 10 x 15
##     arrest   age race  sex   arrestDate arrestTime arrestLocation
##      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1  1.11e7     0 B     F     01/24/2011 12:45      3700 Garrison…
##  2  1.12e7     0 W     M     03/22/2011 08:00      &lt;NA&gt;          
##  3 NA          0 &lt;NA&gt;  &lt;NA&gt;  03/28/2011 15:25      3600 Townsend…
##  4 NA          0 B     M     03/30/2011 16:00      &lt;NA&gt;          
##  5 NA          0 W     F     04/07/2011 20:30      &lt;NA&gt;          
##  6  1.12e7     0 W     F     05/20/2011 02:00      &lt;NA&gt;          
##  7  1.12e7     0 B     M     06/21/2011 21:15      2700 Harford …
##  8  1.13e7     0 B     M     09/04/2011 10:30      &lt;NA&gt;          
##  9  1.13e7     0 B     M     09/28/2011 21:16      500 E Lexingt…
## 10  1.14e7     0 &lt;NA&gt;  &lt;NA&gt;  12/02/2011 19:20      4600 Park Hei…
## # … with 8 more variables: incidentOffense &lt;chr&gt;, incidentLocation &lt;chr&gt;,
## #   charge &lt;chr&gt;, chargeDescription &lt;chr&gt;, district &lt;chr&gt;, post &lt;dbl&gt;,
## #   neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

The `arrange` operation sorts entities by increasing value of the attributes passed as arguments. 

The `desc` helper function is used to indicate sorting by decreasing value. For example, to find the arrests with the 10 _oldest_ subjects we would use:


```r
arrest_tab %&gt;%
  arrange(desc(age)) %&gt;%
  slice(1:10)
```

```
## # A tibble: 10 x 15
##     arrest   age race  sex   arrestDate arrestTime arrestLocation
##      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1  1.13e7    87 B     M     08/28/2011 15:00      3200 E Baltim…
##  2  1.25e7    87 B     M     08/14/2012 07:25      &lt;NA&gt;          
##  3  1.12e7    86 B     M     02/22/2011 15:15      700 W Saratog…
##  4  1.11e7    85 W     M     01/25/2011 08:05      3100 Pulaski …
##  5  1.12e7    85 B     M     03/04/2011 09:23      2000 Ellswort…
##  6  1.14e7    84 B     M     12/27/2011 14:15      2000 W Pratt …
##  7 NA         84 B     M     01/11/2012 11:00      &lt;NA&gt;          
##  8  1.26e7    84 B     M     11/08/2012 06:40      &lt;NA&gt;          
##  9  1.12e7    82 B     M     05/17/2011 19:50      1300 Mchenry …
## 10  1.13e7    80 B     M     09/26/2011 10:15      3000 Harlem A…
## # … with 8 more variables: incidentOffense &lt;chr&gt;, incidentLocation &lt;chr&gt;,
## #   charge &lt;chr&gt;, chargeDescription &lt;chr&gt;, district &lt;chr&gt;, post &lt;dbl&gt;,
## #   neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

## Operations that create new attributes

We will often see that for many analyses, be it for interpretation or for statistical modeling, we will create new attributes based on existing attributes in a dataset. 

![](img/mutate.png)

Suppose I want to represent age in months rather than years in our dataset. To do so I would multiply 12 to the existing age attribute. The function `mutate` creates new attributes based on the result of a given expression:


```r
arrest_tab %&gt;%
  mutate(age_months = 12 * age) %&gt;%
  select(arrest, age, age_months)
```

```
## # A tibble: 104,528 x 3
##      arrest   age age_months
##       &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;
##  1 11126858    23        276
##  2 11127013    37        444
##  3 11126887    46        552
##  4 11126873    50        600
##  5 11126968    33        396
##  6 11127041    41        492
##  7 11126932    29        348
##  8 11126940    20        240
##  9 11127051    24        288
## 10 11127018    53        636
## # … with 104,518 more rows
```

## Operations that summarize attribute values over entities

Once we have a set of entities and attributes in a given data frame, we may need to summarize attribute values over the set of entities in the data frame. It collapses the data frame to a single row containing the desired attribute summaries.

![](img/summarize.png)

Continuing with the example we have seen below, we may want to know what the minmum, maximum and average age in the dataset is:



```r
summarize(arrest_tab, min_age=min(age), mean_age=mean(age), max_age=max(age))
```

```
## # A tibble: 1 x 3
##   min_age mean_age max_age
##     &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1       0     33.2      87
```

The `summarize` functions takes a data frame and calls a summary function over attributes of the data frame. Common summary functions to use include:

| Operation(s) | Result |
|-----------|-------------|
| `mean`, `median` | average and median attribute value, respectively |
| `sd` | standard deviation of attribute values |
| `min`, `max` | minimum and maximum attribute values, respectively |
| `n`, `n_distinct` | number of attribute values and number of _distinct_ attribute values |
| `any`, `all` | for logical attributes (TRUE/FALSE): is `any` attribute value TRUE, or are `all` attribute values TRUE |

Let's see the number of distinct districts in our dataset:


```r
summarize(arrest_tab, n_distinct(district))
```

```
## # A tibble: 1 x 1
##   `n_distinct(district)`
##                    &lt;int&gt;
## 1                     10
```

We may also refer to these summarization operation as **aggregation** since we are computing _aggregates_ of attribute values.

## Operations that group entities

Summarization (therefore aggregation) goes hand in hand with data grouping, where summaries are computed _conditioned_ on other attributes. The notion of _conditioning_ is fundamental to data analysis and we will see it very frequently through the course. It is the basis of statistical analysis and Machine Learning models and it is essential in understanding the design of effective visualizations.

![](img/groupby.png)

The goal is to group entities with the same value of one or
more attributes. The `group_by` function in essence annotates the rows of a data frame as belonging to a specific group based on the value of some chosen attributes. This call returns a data frame that is grouped by the value of the `district` attribute.


```r
group_by(arrest_tab, district)
```

```
## # A tibble: 104,528 x 15
## # Groups:   district [10]
##    arrest   age race  sex   arrestDate arrestTime arrestLocation
##     &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;      &lt;time&gt;     &lt;chr&gt;         
##  1 1.11e7    23 B     M     01/01/2011 00'00"     &lt;NA&gt;          
##  2 1.11e7    37 B     M     01/01/2011 01'00"     2000 Wilkens …
##  3 1.11e7    46 B     M     01/01/2011 01'00"     2800 Mayfield…
##  4 1.11e7    50 B     M     01/01/2011 04'00"     2100 Ashburto…
##  5 1.11e7    33 B     M     01/01/2011 05'00"     4000 Wilsby A…
##  6 1.11e7    41 B     M     01/01/2011 05'00"     2900 Spellman…
##  7 1.11e7    29 B     M     01/01/2011 05'00"     800 N Monroe …
##  8 1.11e7    20 W     M     01/01/2011 05'00"     5200 Moravia …
##  9 1.11e7    24 B     M     01/01/2011 07'00"     2400 Gainsdbo…
## 10 1.11e7    53 B     M     01/01/2011 15'00"     3300 Woodland…
## # … with 104,518 more rows, and 8 more variables: incidentOffense &lt;chr&gt;,
## #   incidentLocation &lt;chr&gt;, charge &lt;chr&gt;, chargeDescription &lt;chr&gt;,
## #   district &lt;chr&gt;, post &lt;dbl&gt;, neighborhood &lt;chr&gt;, `Location 1` &lt;chr&gt;
```

Subsequent operations are then performed **for each group independently**. For example, when `summarize` is applied to a grouped data frame, summaries are computed for each group of entities, rather than the whole set of entities.

For instance, let's calculate minimum, maximum and average age for each district in our dataset:


```r
arrest_tab %&gt;%
  group_by(district) %&gt;%
  summarize(min_age=min(age), max_age=max(age), mean_age=mean(age))
```

```
## # A tibble: 10 x 4
##    district     min_age max_age mean_age
##    &lt;chr&gt;          &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
##  1 CENTRAL            0      86     33.0
##  2 EASTERN            0      85     34.1
##  3 NORTHEASTERN       0      78     30.4
##  4 NORTHERN          14      80     33.1
##  5 NORTHWESTERN       0      78     34.6
##  6 SOUTHEASTERN       0      87     32.5
##  7 SOUTHERN           0      84     32.3
##  8 SOUTHWESTERN       0      80     32.4
##  9 WESTERN            0      73     34.4
## 10 &lt;NA&gt;               0      87     33.4
```

Note that after this operation we have effectively changed the entities represented in the result. The entities in our original dataset are arrests while the entities for the result of the last example are the districts. This is a general property of group_by and summarize: it defines a data set where entities are defined by distinct values of the attributes we use for grouping.

Let's look at another example combining some of the operations we have seen so far. Let's compute the average age for subjects 21 years or older grouped by district and sex:


```r
arrest_tab %&gt;%
  filter(age &gt;= 21) %&gt;%
  group_by(district, sex) %&gt;%
  summarize(mean_age=mean(age))
```

```
## # A tibble: 20 x 3
## # Groups:   district [10]
##    district     sex   mean_age
##    &lt;chr&gt;        &lt;chr&gt;    &lt;dbl&gt;
##  1 CENTRAL      F         35.7
##  2 CENTRAL      M         35.3
##  3 EASTERN      F         36.9
##  4 EASTERN      M         37.1
##  5 NORTHEASTERN F         33.5
##  6 NORTHEASTERN M         32.8
##  7 NORTHERN     F         35.9
##  8 NORTHERN     M         35.6
##  9 NORTHWESTERN F         37.5
## 10 NORTHWESTERN M         37.2
## 11 SOUTHEASTERN F         33.3
## 12 SOUTHEASTERN M         34.7
## 13 SOUTHERN     F         33.7
## 14 SOUTHERN     M         34.5
## 15 SOUTHWESTERN F         35.4
## 16 SOUTHWESTERN M         35.0
## 17 WESTERN      F         37.1
## 18 WESTERN      M         37.3
## 19 &lt;NA&gt;         F         34.7
## 20 &lt;NA&gt;         M         35.5
```

**Exercise**: Write a data operation pipeline that

1) filters records to the southern district and ages between 18 and 25
2) computes mean arrest age for each sex

## Vectors

We briefly saw previously operators to create vectors in R. For instance, we can use `seq` to create a vector that consists of a sequence of integers:


```r
multiples_of_three &lt;- seq(3, 30, by=3)
multiples_of_three
```

```
##  [1]  3  6  9 12 15 18 21 24 27 30
```

Let's how this is represented in R (the `str` is very handy to do this type of digging around):


```r
str(multiples_of_three)
```

```
##  num [1:10] 3 6 9 12 15 18 21 24 27 30
```

So, this is a `numeric` vector of length 10. Like many other languages we use square brackets `[]` to index vectors:


```r
multiples_of_three[1]
```

```
## [1] 3
```

We can use ranges as before


```r
multiples_of_three[1:4]
```

```
## [1]  3  6  9 12
```

We can use vectors of non-negative integers for indexing:


```r
multiples_of_three[c(1,3,5)]
```

```
## [1]  3  9 15
```

Or even logical vectors:


```r
multiples_of_three[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)]
```

```
## [1]  3  9 15 21 27
```

In R, most operations are designed to work with vectors directly (we call that _vectorized_). For example, if I want to add two vectors together I would write: (look no `for` loop!):


```r
multiples_of_three + multiples_of_three
```

```
##  [1]  6 12 18 24 30 36 42 48 54 60
```

This also works for other arithmetic and logical operations (e.g., `-`, `*`, `/`, `&amp;`, `|`). Give them a try!

In data analysis the _vector_ is probably the most fundamental data type (other than basic numbers, strings, etc.). Why? Consider getting data about one attribute, say height, for a group of people. What do you get? An array of numbers, all in the same unit (say feet, inches or centimeters). How about their name? Then you get an array of strings. Abstractly, we think of vectors as arrays of values, all of the same _class_ or datatype. 

## Attributes as vectors

In fact, in the data frames we have been working on, each column, corresponding to an attribute, is a vector. We use the `pull` function to extract a vector from a data frame. We can then operate index them, or operate on them as vectors


```r
age_vec &lt;- arrest_tab %&gt;% pull(age)
age_vec[1:10]
```

```
##  [1] 23 37 46 50 33 41 29 20 24 53
```


```r
12 * age_vec[1:10]
```

```
##  [1] 276 444 552 600 396 492 348 240 288 636
```

We previously saw how the `$` operator serves the same function. 


```r
age_vec &lt;- arrest_tab$age
age_vec[1:10]
```

```
##  [1] 23 37 46 50 33 41 29 20 24 53
```

The `pull` function however, can be used as part of a pipeline (using operator `%&gt;%`):


```r
arrest_tab %&gt;%
  pull(age) %&gt;%
  mean()
```

```
## [1] 33.19639
```

## Functions

Once we have established useful pipelines for a dataset we will want to abstract them into reusable functions that we can apply in other analyses. To do that we would write our own functions that encapsulate the pipelines we have created. As an example, take a function that executes the age by district/sex summarization we created before:


```r
summarize_district &lt;- function(df) {
  df %&gt;%
    filter(age &gt;= 21) %&gt;%
    group_by(district, sex) %&gt;%
    summarize(mean_age=mean(age))
}
```

You can include multiple expressions in the function definition (inside brackets `{}`). Notice there is no `return` statement in this function. When a function is called, it returns the value of the last expression in the function definition. In this example, it would be the data frame we get from applying the pipeline of operations. 

You can find more information about vectors, functions and other programming matters we might run into in class in Chapters 17-21 of [R for Data Science](http://r4ds.had.co.nz/program-intro.html)

**Exercise** Abstract the pipeline you wrote in the previous unit into a function that works for arbitrary districts. 
The function should take arguments `df` and `district`.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>
<script>
remark.macros['scale'] = function (percentage) {
  var url = this;
  return '<img src="' + url + '" style=width: ' + percentage + '"/>';
};
</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
