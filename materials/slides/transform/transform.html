<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Transformations</title>
    <meta charset="utf-8" />
    <meta name="author" content="Héctor Corrada Bravo" />
    <meta name="date" content="2020-03-11" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: title-slide, center, middle
count: false

.banner[![](img/epiviz.png)]

.title[Introduction to Data Science: Data Transformations]

.author[Héctor Corrada Bravo]

.other-info[
University of Maryland, College Park, USA  
2020-03-11
]

.logo[![](img/logo.png)]



---
layout: true

## EDA: Data Transformations

---


How is data distributed?
  - visual EDA
  - quantitative summaries
  
--

Now consider transformations of attributes: 
  - help interpretation of data analyses 
  - help application statistical and machine learning models

---
layout: true

## Centering and scaling

---

A very common and important transformation  is to scale data to a common unit-less scale. 

Transforming variables from whatever units they are measured (e.g., diamond depth percentage) 

into "standard deviations away from the mean" units (_standard units_, or `\(z\)`-score). 

---

Given data `\(x = x_1, x_2, \ldots, x_n\)`, the transformation applied to obtain centered and scaled variable `\(z\)` is:

$$
z_i = \frac{(x_i - \overline{x})}{\mathrm{sd}(x)}
$$

where `\(\overline{x}\)` is the mean of data `\(x\)`, and `\(\mathrm{sd}(x)\)` is its standard deviation.

---
class: split-50

.column[
```r
diamonds %&gt;%
  mutate(scaled_depth = (depth - mean(depth)) / sd(depth)) %&gt;%
  ggplot(aes(x=scaled_depth)) +
    geom_histogram(binwidth=.5)
```
]

&lt;img src="transform_files/figure-html/unnamed-chunk-2-1.png" style="display: block; margin: auto;" /&gt;

Question: what is the mean of `\(z\)`? What is it's standard deviation? 

---

Another name for this transformation is to _standardize_ a variable.

--

After transformation: 
 - all variables in a dataset are in the same, and thus comparable, units.
 - all variables have the same mean and variance

--

This is very helpful for _multivariate_ statistical and ML analyses

---

On occasion, you will have use to apply transformations that only _center_ (but not scale) data:

$$
z_i = (x_i - \overline{x})
$$

---

Or, apply transformations that only _scale_ (but not center) data:

$$
z_i = \frac{x_i}{\mathrm{sd}(x)}
$$

---
layout: true

## Treating categorical variables as numeric

---

Many modeling algorithms work strictly on numeric measurements. 

For example: 
  - linear regression, or
  - support vector machines
  
Strictly defined for numeric measurements.

--

In this case, need to transform categorical variables into something that we can treat as numeric. 

---

Let's see a couple of important guidelines for _binary_ variables:

categorical variables that only take two values, e.g. 

- `health_insurance` Yes/No
- `cat_picture` Yes/No

---


One option is to encode one value of the variable as 1 and the other as 0. For instance:




```r
Wage %&gt;%
  mutate(numeric_insurance = ifelse(health_ins == "1. Yes", 1, 0)) %&gt;%
  select(year, age, health_ins, numeric_insurance) %&gt;%
  head()
```

```
##   year age health_ins numeric_insurance
## 1 2006  18      2. No                 0
## 2 2004  24      2. No                 0
## 3 2003  45     1. Yes                 1
## 4 2003  43     1. Yes                 1
## 5 2005  50     1. Yes                 1
## 6 2008  54     1. Yes                 1
```

---

Another option is to encode one value as 1 and the other as -1:


```r
Wage %&gt;%
  mutate(numeric_insurance = ifelse(health_ins == "1. Yes", 1, -1)) %&gt;%
  select(year, age, health_ins, numeric_insurance) %&gt;%
  head()
```

```
##   year age health_ins numeric_insurance
## 1 2006  18      2. No                -1
## 2 2004  24      2. No                -1
## 3 2003  45     1. Yes                 1
## 4 2003  43     1. Yes                 1
## 5 2005  50     1. Yes                 1
## 6 2008  54     1. Yes                 1
```

---

The decision of which of these two transformations to use is based on the method to use or the goal of your analysis. 

--

E.g, predict `wage` based on `health insurance status` (coded as 0/1) let's us make statements like: "on average, wage increases by $XX if a person has health insurance". 

--

But, to predict `health insurance status` based on other attributes, a Support Vector Machine requires `health insurance status` to be coded as +1/-1

---

For categorical attributes with more than two values, we extend this idea and encode _each_ value of the categorical variable as a 0/1 column. 

You will see this referred to as _one-hot-encoding_.

---


```r
Wage %&gt;%
  mutate(race_white = ifelse(race == "1. White", 1, 0),
         race_black = ifelse(race == "2. Black", 1, 0),
         race_asian = ifelse(race == "3. Asian", 1, 0),
         race_other = ifelse(race == "4. Other", 1, 0)) %&gt;%
  select(starts_with("race")) %&gt;%
  sample_n(5)
```

```
##       race race_white race_black race_asian race_other
## 1 2. Black          0          1          0          0
## 2 1. White          1          0          0          0
## 3 2. Black          0          1          0          0
## 4 1. White          1          0          0          0
## 5 1. White          1          0          0          0
```

---
layout: true

### Discretizing continuous values. 

---

How about transforming data in the other direction, from continuous to discrete values. 

This can make it easier to compare differences related to continuous measurements: 

Do doctors prescribe a certain medication to older kids more often? Is there a difference in wage based on age?

---

It is also a useful way of capturing non-linear relationships in data: we will see this in our regression and prediction unit. 

Two standard methods used for discretization are to use **equal-length** bins, where variable range is divided into bins _regardless_ of the data distribution.

---
class: split-50



.column[
```r
flights %&gt;% 
  mutate(dep_delay_discrete = cut(dep_delay, breaks=100)) %&gt;%
  ggplot(aes(x=dep_delay_discrete)) +
  geom_bar()
```
]

.column[
&lt;img src="transform_files/figure-html/unnamed-chunk-8-1.png" style="display: block; margin: auto;" /&gt;
]
---

The second approach uses **equal-sized** bins, where the range is divided into bins _based_ on data distribution

---
class: split-50

.column[
```r
flights %&gt;% 
  mutate(dep_delay_discrete = cut(dep_delay, 
          breaks=quantile(dep_delay, probs=seq(0,1,len=11), na.rm=TRUE))) %&gt;%
  ggplot(aes(x=dep_delay_discrete)) +
  geom_bar()
```
]

.column[
&lt;img src="transform_files/figure-html/unnamed-chunk-9-1.png" style="display: block; margin: auto;" /&gt;
]
---
layout: true

## Skewed Data

---

In many data analysis, variables will have a _skewed_ distribution over their range. 

In the last section we saw one way of defining skew using quartiles and median. 

Variables with skewed distributions can be hard to incorporate into some modeling procedures, especially in the presence of other variables that are not skewed. 

---

Skewed data may arise when measuring *multiplicative* processes. In this case, interpretation of data may be more intiuitive after a transformation.

We have seen an example of skewed data previously when we looked at departure delays in our flights dataset.

---
class: split-50



.column[
```r
flights %&gt;% ggplot(aes(x=dep_delay)) +
  geom_histogram(binwidth=30)
```
]

.column[
&lt;img src="transform_files/figure-html/unnamed-chunk-11-1.png" style="display: block; margin: auto;" /&gt;
]

---
In many cases a logarithmic transform is an appropriate transformation to reduce data skew:

- If values are all positive: apply `log2` transform
- If some values are negative, two options
  - Started Log: shift all values so they are positive, apply `log2`
  - Signed Log: `\(sign(x) \times log2(abs(x) + 1)\)`.
  
---
class: split-50

Here is a signed log transformation of departure delay data:

.column[
```r
transformed_flights &lt;- flights %&gt;%
  mutate(transformed_dep_delay = sign(dep_delay) * log2(abs(dep_delay) + 1))

transformed_flights %&gt;%
  ggplot(aes(x=transformed_dep_delay)) +
    geom_histogram(binwidth=1)
```
]

.column[
&lt;img src="transform_files/figure-html/unnamed-chunk-12-1.png" style="display: block; margin: auto;" /&gt;
]

---
layout: false

## Summary

Given what we learn from EDA (visually and statistically), we can guide decisions on data transformations

- Change data types continuous &lt;-&gt; numeric
- Standardization
- Log-transforms (reduce skew, also variance stabilization)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<script>
remark.macros['scale'] = function (percentage) {
  var url = this;
  return '<img src="' + url + '" style=width: ' + percentage + '"/>';
};
</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
