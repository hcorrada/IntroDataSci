[
["db-parting-shots.html", "15 DB Parting Shots 15.1 Database Query Optimization 15.2 JSON Data Model", " 15 DB Parting Shots 15.1 Database Query Optimization Earlier we made the distinction that SQL is a declarative language rather than a procedural language. A reason why data base systems rely on a declarative language is that it allows the system to decide how to evaluate a query most efficiently. Let’s think about this briefly. Consider a database where we have two tables Batting and Master and we want to evaluate this query: that what is the maximum batting “average” for a player from the state of California? select max(1.0 * b.H / b.AB) as best_ba from Batting as b join Master as m on b.playerId = m.playerId where b.AB &gt;= 100 and m.birthState = &quot;CA&quot; Table 15.1: 1 records best_ba 0.405701754385965 Now, let’s do the same computation using dplyr operations: library(Lahman) library(tidyverse) Here is one version that joins the two tables before filtering the rows that are included in the result. Batting %&gt;% inner_join(Master, by=&quot;playerID&quot;) %&gt;% filter(AB &gt;= 100, birthState == &quot;CA&quot;) %&gt;% mutate(AB=1.0 * H / AB) %&gt;% summarize(max(AB)) ## max(AB) ## 1 0.4057018 Here is a second version that filters the rows of the tables before joining the two tables. Batting %&gt;% filter(AB &gt;= 100) %&gt;% inner_join( Master %&gt;% filter(birthState == &quot;CA&quot;) ) %&gt;% mutate(AB = 1.0 * H / AB) %&gt;% summarize(max(AB)) ## Joining, by = &quot;playerID&quot; ## max(AB) ## 1 0.4057018 They both give the same result of course, but which one should be more efficient? In SQL we only write the one query describing our desired result, with the procedural versions with dplyr we need to think which of the two versions is more efficient. Database systems use query optimization to decide how to evaluate query efficiently. The goal of query optimization is to decide the most efficient query plan to use to evaluate a query out of the many possible candidate plans it could use. It needs to solve two problems: search the space of possible plans, approximate the cost of evaluating a specific plan. Let’s ignore the first, and discuss briefly the second. We should think of the two procedural versions above as two candidate plans that the DB system could use to evaluate the query. Query optimzation approximates what it would cost to evaluate each of the two plans and decides to use the most efficient plan. So, how does it approximate cost? A few ingredients are used: Access cost: how much will it cost to access rows that satisfy a given predicate (where clause)? Consider the Master table. In our query we only need to find rows for players born in California. Suppose we have an index based on attribute birthState, e.g. a hash table that allows us to find rows for players from a specific state very efficiently. In that case, accessing these rows using the index is much more efficient than scanning the entire table. This is why creating indexes for tables becomes important. Operation cost: how much will it cost to perform a join? There is a difference between comparing every pair of rows in order to compute a join, versus using indexes to find a small number of rows that satisfy the join condition efficiently? For example, if the Batting table has an index on playerId it will be cheaper to join with a filtered Master table, i.e., only considering rows for players born in California. Result size estimation: how many rows will we get after we perform a join? We can use information on key constraints to estimate this type of result. Additionally, these estimates also depend on the number of rows that satisfy certain predicates (e.g., number of players born in California) so systems often use histograms to make these estimates. As database system users we may create indices or key constraints that guide the query optimizer to choose more efficient queries. 15.2 JSON Data Model The Entity-Relational data model we have described so far is mostly defined for structured data: where a specific and consistent schema is assumed. Data models like XML and JSON are instead intended for semi-structured data. 15.2.0.1 XML: eXtensible Markup Language Data models like XML rely on flexible, self-describing schemas: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- Edited by XMLSpy --&gt; &lt;CATALOG&gt; &lt;CD&gt; &lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt; &lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt; &lt;COUNTRY&gt;USA&lt;/COUNTRY&gt; &lt;COMPANY&gt;Columbia&lt;/COMPANY&gt; &lt;PRICE&gt;10.90&lt;/PRICE&gt; &lt;YEAR&gt;1985&lt;/YEAR&gt; &lt;/CD&gt; &lt;CD&gt; &lt;TITLE&gt;Hide your heart&lt;/TITLE&gt; &lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt; &lt;COUNTRY&gt;UK&lt;/COUNTRY&gt; &lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt; &lt;PRICE&gt;9.90&lt;/PRICE&gt; &lt;YEAR&gt;1988&lt;/YEAR&gt; &lt;/CD&gt; ... 15.2.0.2 JSON: Javascript Object Notation Very similar to XML and seems to be replacing it for many purposes { &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;isAlive&quot;: true, &quot;age&quot;: 25, &quot;height_cm&quot;: 167.6, &quot;address&quot;: { &quot;streetAddress&quot;: &quot;21 2nd Street&quot;, &quot;city&quot;: &quot;New York&quot;, &quot;state&quot;: &quot;NY&quot;, &quot;postalCode&quot;: &quot;10021-3100&quot; }, &quot;phoneNumbers&quot;: [ { &quot;type&quot;: &quot;home&quot;, &quot;number&quot;: &quot;212 555-1234&quot; }, { &quot;type&quot;: &quot;office&quot;, &quot;number&quot;: &quot;646 555-4567&quot; } ], &quot;children&quot;: [], &quot;spouse&quot;: null } This is the format most contemporary data REST APIs use to transfer data. For instance, here is part of a JSON record from a Twitter stream: { &quot;created_at&quot;:&quot;Sun May 05 14:01:34+00002013&quot;, &quot;id&quot;:331046012875583488, &quot;id_str&quot;:&quot;331046012875583488&quot;, &quot;text&quot;:&quot;\\u0425\\u043e\\u0447\\u0443, \\u0447\\u0442\\u043e\\u0431 \\u0442\\u044b \\u0441\\u0434\\u0435\\u043b\\u0430\\u043b \\u0432\\u0441\\u0451 \\u043d\\u0435\\u043e\\u0431\\u0445\\u043e\\u0434\\u0438\\u043c\\u043e\\u0435.\\n \\\\,,\\\\ *_* \\/,,\\/&quot;, &quot;source&quot;:&quot;\\u003ca href=\\&quot;http:\\/\\/twitterfeed.com\\&quot;rel=\\&quot;nofollow\\&quot;\\u003etwitterfeed\\u003c\\/a\\u003e&quot;, &quot;in_reply_to_user_id_str&quot;:null, &quot;user&quot;:{ &quot;id&quot;:548422428, &quot;id_str&quot;:&quot;548422428&quot;, &quot;name&quot;:&quot;\\u0410\\u0439\\u0433\\u0435\\u0440\\u0438\\u043c \\u041f\\u043e\\u0433\\u043e\\u0434\\u0438\\u043d\\u0430&quot;, &quot;screen_name&quot;:&quot;paddybyrny&quot;, &quot;location&quot;:&quot;\\u0420\\u043e\\u0441\\u0441\\u0438\\u044f;\\u0412\\u043b\\u0430\\u0434\\u0438\\u0432\\u043e\\u0441\\u0442\\u043e\\u043a&quot;, &quot;followers_count&quot;:4188, &quot;friends_count&quot;:4281, &quot;lang&quot;:&quot;en&quot;, &quot;profile_background_image_url&quot;:&quot;http:\\/\\/a0.twimg.com\\/images\\/themes\\/theme1\\/bg.png&quot;, }, &quot;geo&quot;:null, &quot;coordinates&quot;:null, &quot;entities&quot;:{ &quot;hashtags&quot;:[],&quot;symbols&quot;:[],&quot;urls&quot;:[],&quot;user_mentions&quot;:[] },&quot;favorited&quot;:false,&quot;retweeted&quot;:false,&quot;filter_level&quot;:&quot;medium&quot;,&quot;lang&quot;:&quot;ru&quot;} "]
]
